import type { WriterFunction } from 'ts-morph';
import { Project, StructureKind, VariableDeclarationKind, Writers } from 'ts-morph';
import {
  AUTOGENERATED_CODE_COMMENT_STR,
  BLOG_CATEGORIES_CONST_STR,
  GENERATIONS_TARGET_FOLDER,
  I18N_CATEGORIES_REQUIRED_EXTRA_FIELDS,
  I18N_CATEGORIES_REQUIRED_EXTRA_FIELDS_PREFIX,
  I18N_SUBCATEGORIES_REQUIRED_EXTRA_FIELDS,
  TS_MORPH_FORMATTER_SETTINGS
} from '../../config';
import type { CategoriesMetadatas } from '../../types/metadatas';

const emptyString = '';
const PREFIXED_I18N_CATEGORIES_REQUIRED_EXTRA_FIELDS = I18N_CATEGORIES_REQUIRED_EXTRA_FIELDS.map(
  (field) => I18N_CATEGORIES_REQUIRED_EXTRA_FIELDS_PREFIX + field
);

type BlogCategoriesSchemaSubcategoryEntity = Record<string, unknown>;
type BlogCategoriesSchema = Record<string, BlogCategoriesSchemaSubcategoryEntity>;

function generateSchema(blogArchitecture: CategoriesMetadatas) {
  const schema = {} as BlogCategoriesSchema;

  for (const category in blogArchitecture) {
    const subcategories = blogArchitecture[category];

    schema[category] = {};
    for (const extraField of PREFIXED_I18N_CATEGORIES_REQUIRED_EXTRA_FIELDS) {
      schema[category][extraField] = emptyString;
    }

    Object.keys(subcategories).forEach((subcategory) => {
      if (I18N_SUBCATEGORIES_REQUIRED_EXTRA_FIELDS.length <= 0) {
        schema[category][subcategory] = emptyString;
        return;
      }
      const obj = {} as BlogCategoriesSchemaSubcategoryEntity;
      for (const extraField of I18N_SUBCATEGORIES_REQUIRED_EXTRA_FIELDS) {
        obj[extraField] = emptyString;
      }
      schema[category][subcategory] = obj;
    });
  }

  return schema;
}

function generateTrailingTrivia() {
  const CategoriesMetadatasBaseProps = 'Record<string, SubcategoriesMetadatas>';

  const CategoriesMetadatas =
    'type CategoriesMetadatas =' +
    ' ' +
    (PREFIXED_I18N_CATEGORIES_REQUIRED_EXTRA_FIELDS.length > 0
      ? [
          `Record<${PREFIXED_I18N_CATEGORIES_REQUIRED_EXTRA_FIELDS.map((field) => `'${field}'`).join(' | ')}, EmptyString>`,
          CategoriesMetadatasBaseProps
        ].join(' | ')
      : CategoriesMetadatasBaseProps);

  const SubcategoriesMetadatas =
    'type SubcategoriesMetadatas =' +
    ' ' +
    (I18N_SUBCATEGORIES_REQUIRED_EXTRA_FIELDS.length > 0
      ? `Record<${I18N_SUBCATEGORIES_REQUIRED_EXTRA_FIELDS.map((field) => `'${field}'`).join(' | ')}, EmptyString>`
      : 'EmptyString');

  return [
    "type EmptyString = '';",
    `${SubcategoriesMetadatas};`,
    `${CategoriesMetadatas};`,
    'type BlogCategoriesArtifact = Record<string, CategoriesMetadatas>'
  ].join('\n');
}

export default function generateI18nBlogCategories(blogArchitecture: CategoriesMetadatas) {
  const project = new Project();

  const initializerWriterFunction: WriterFunction = Writers.assertion(
    JSON.stringify(generateSchema(blogArchitecture), null, 2).replace(/""|''|``/g, '_'),
    'const satisfies BlogCategoriesArtifact;\n'
  );

  const sourceFile = project.createSourceFile(
    `${GENERATIONS_TARGET_FOLDER}/${BLOG_CATEGORIES_CONST_STR}.ts`,
    {
      statements: [
        {
          kind: StructureKind.VariableStatement,
          declarationKind: VariableDeclarationKind.Const,
          declarations: [
            {
              name: '_',
              initializer: "''",
              type: 'EmptyString'
            }
          ]
        },
        {
          kind: StructureKind.VariableStatement,
          declarationKind: VariableDeclarationKind.Const,
          declarations: [
            {
              name: BLOG_CATEGORIES_CONST_STR,
              initializer: initializerWriterFunction,
              trailingTrivia: generateTrailingTrivia()
            }
          ],
          isExported: false
        }
      ]
    },
    { overwrite: true }
  );
  const oldTextLength = sourceFile.getText().length;

  sourceFile.insertText(0, AUTOGENERATED_CODE_COMMENT_STR);

  sourceFile.insertText(oldTextLength + AUTOGENERATED_CODE_COMMENT_STR.length, `export default ${BLOG_CATEGORIES_CONST_STR};`);
  sourceFile.formatText(TS_MORPH_FORMATTER_SETTINGS);
  sourceFile.saveSync();
}
