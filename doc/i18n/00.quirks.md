# i18n quirks

There are certain subtleties that you must know about the i18n in this codebase.

Initially, the default language also was the "Schema" of different languages.  
As the codebase evolved, it seemed wise to abstract it as a separate entity, enabling the declaration of the schema on one side and languages on the
other.

This greatly simplifies changing the default language in the codebase, removing the need to "Swap" some code of the language previously used as the
basis for defining both the schema and the (old) default language, with some code of the (new) default language.

Furthermore, it enables the dynamic declaration of a "Shared Vocabulary" structure, to share common values across various namespaces within our
vocabulary, since avoiding hard-coded duplicate values is essential in such data structures.

Another motivation was also to maintain a _prebuilder_ code that is as simple and predictable as possible.

The _prebuilder_ is a standalone NPM package. It does not "import" any scripts from the codebase. Instead, it opens them as files via the _filesystem_
and parses them.

The ability to dynamically define values based on variables scattered in different parts of the code made implementing this feature nightmarish. In my
opinion, this indicated a poor design choice rather than a flawed implementation of the _prebuilder_.

---

So, it was from all these questions that the need and obviousness of creating a `schema.ts` file arose.

## The _locale schema_: a powerful and dynamic interface

Let's open [the `schema.ts` file](/src/i18n/locales/schema.ts), and look at its structure.

### 1. SHARED_VOCAB_SCHEMA

This section of the code is used to define what we would like to define as "Duplicates" in our vocabulary. It allows us to define these values in only
one place across our various translation files.

For example:

```ts
export const SHARED_VOCAB_SCHEMA = {
  'pages-titles': {
    ...pagesTitles,

    homepage: _,
    'sign-up': _
  }
} as const satisfies TypedLeafsJSONData<NotScanned>;
```

### 2. export default {...}

This second and final section of the code is where we find concretely what will be our schema.  
This is where we can observe some **injections**.

For instance:

```ts
export default {
  blog: {
    categories: blogCategories // * ... Injecting autogenerated code
  },
  // * ...
  'pages-titles': SHARED_VOCAB_SCHEMA['pages-titles'] // * ... Injecting code from our shared vocab schema definition
  // * ...
} as const satisfies TypedLeafsJSONData<MaybeScanned>;
```

Then, the entire remaining vocabulary will be defined here.

Likewise:

```ts
export default {
  // * ...
  _infos: {
    lng: '__SCANNED__'
  },

  navbar: {
    assistance: _
  },

  auth: {
    login: _,
    logout: _,
    signup: _
  }
  // * ...
} as const satisfies TypedLeafsJSONData<MaybeScanned>;
```

As it is just a _schema_, all the "values" of this object are empty.  
As a convention, it was preferred to represent this as a "hole", using `_`.

Finally, a type will be dynamically generated based on this definition in the `export default`, thanks to some recursive types black art: this is
`VocabType`.

Those subtleties allow us to use _spread operators_ and _assignments_ in the `export default` definition, as we designed a little earlier when we
talked about "injections", and use it later as a type, using `VocabType`. This flexibility and code readability would be impossible if we were simply
using a _TypeScript_ interface.
